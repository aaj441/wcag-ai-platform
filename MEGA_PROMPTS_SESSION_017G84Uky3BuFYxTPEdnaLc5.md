# WCAG AI Platform - 10 Mega Prompts
**Session ID:** 017G84Uky3BuFYxTPEdnaLc5
**Generated:** 2025-11-18
**Purpose:** Production-focused prompts for system enhancement and optimization

---

## Mega Prompt #1: AI Remediation Engine Optimization

**Objective:** Enhance the AI-powered fix generation system to increase fix acceptance rate from 65% to 85%+ and reduce false positives by 40%.

**Current State:**
- Claude 3.5 Sonnet generates fixes with 0.0-1.0 confidence scoring
- Consultant approval workflow reviews and disputes fixes
- Feedback loop learns from approved/disputed fixes
- 21 service classes implement remediation logic
- Evidence vault stores 90-day scan history

**Requirements:**
1. **Confidence Scoring Enhancement**: Implement multi-factor confidence calculation incorporating:
   - WCAG success criteria match accuracy
   - Historical fix acceptance rate per violation type
   - Code complexity vs. accuracy correlation
   - Temporal trends (improving/degrading model performance)
   - Context window adequacy assessment

2. **Prompt Engineering Optimization**:
   - Create violation-type-specific prompts (100+ criteria variation)
   - Implement few-shot learning with approved historical fixes
   - Add constraint-based fix generation (framework-specific, styling-safe)
   - Include fix validation rules pre-generation

3. **Quality Assurance System**:
   - Implement fix replay engine to test against similar violations
   - Create automated test generation for each fix
   - Add browser compatibility checking (Chrome, Firefox, Safari, Edge)
   - Implement accessibility re-testing post-fix

4. **Feedback Loop Optimization**:
   - Batch consultant feedback into training signals
   - Implement A/B testing framework for prompt variations
   - Track fix performance metrics: acceptance rate, time-to-accept, rewrites
   - Identify patterns in disputed fixes

5. **Cost & Performance**:
   - Optimize token usage (target 30% reduction)
   - Implement caching for similar violations
   - Batch fix generation requests
   - Cache successful prompt templates per violation type

**Deliverables:**
- Enhanced AIService with multi-factor scoring
- Violation-specific prompt templates (100+ variations)
- Automated test generation system
- Feedback loop analytics dashboard
- Cost optimization report with 30%+ savings

**Success Metrics:**
- Fix acceptance rate: 65% → 85%+
- False positives reduction: 40%
- Token usage reduction: 30%
- Time-to-consultant-review: 60% faster

---

## Mega Prompt #2: Demographic Targeting & Lead Discovery Engine Transformation

**Objective:** Build an intelligent lead discovery and targeting system that identifies high-risk businesses across 350+ US metros with 90%+ prediction accuracy.

**Current State:**
- 350+ metros with ADA lawsuit trend data
- Industry profiles per metro with risk levels
- Company discovery via Apollo.io and Hunter.io APIs
- Prospect discovery service with risk scoring
- Batch audit capability for multi-site scanning

**Requirements:**
1. **Predictive Risk Scoring**:
   - Implement multi-variable risk model incorporating:
     - Local ADA lawsuit trends (weighted by recency)
     - Industry vertical accessibility compliance rates
     - Company size (employee count) correlation with litigation risk
     - Website accessibility compliance status (via scan)
     - Digital maturity (tech stack analysis)
     - State-specific litigation patterns
   - Target prediction accuracy: 90%+

2. **Lead Qualification & Segmentation**:
   - Create buyer persona system (decision maker identification)
   - Implement lead scoring with 10+ scoring factors
   - Build audience segmentation by:
     - Risk level (critical, high, medium, low)
     - Industry vertical
     - Geography (metro + state)
     - Company size/revenue
     - Digital maturity
   - Auto-qualify leads meeting threshold criteria

3. **Outreach Personalization Engine**:
   - Generate hyper-personalized email campaigns per lead:
     - Reference local ADA lawsuit history
     - Cite industry-specific compliance gaps
     - Include benchmarking vs. competitors
     - Suggest ROI based on compliance improvements
   - Implement A/B testing framework for email variations
   - Track response rates by segment

4. **Batch Intelligence System**:
   - Scan 500+ sites per batch with priority queue
   - Parallel processing with exponential backoff
   - Cache accessibility scores (30-day validity)
   - Generate compliance benchmarking reports per industry
   - Track competitor accessibility metrics

5. **Analytics & Attribution**:
   - Build metrics dashboard showing:
     - Leads generated by metro/industry
     - Cost per qualified lead (CPQL)
     - Conversion funnel by risk segment
     - ROI per outreach campaign
     - Win rate by audience segment
   - Implement attribution modeling

6. **Integration & Automation**:
   - Two-way sync with CRM (Salesforce/HubSpot)
   - Automated outreach email scheduling
   - Lead progress tracking through pipeline
   - Real-time notification system

**Deliverables:**
- Multi-variable risk prediction model (90%+ accuracy)
- Lead qualification and scoring system
- Personalized outreach engine with A/B testing
- Batch scanning orchestration system
- Analytics dashboard with attribution
- CRM integration framework

**Success Metrics:**
- Risk prediction accuracy: 90%+
- Leads qualified per batch: 40%+ improvement
- Email response rate: 15%+ (vs. 8% industry average)
- Cost per qualified lead: 50% reduction
- Outreach campaign ROI: 3:1+

---

## Mega Prompt #3: Deployment Harmony & CI/CD Safety System Enhancement

**Objective:** Build production-grade deployment safety system with pre/post validation, automatic rollback, and zero-downtime deployment capability.

**Current State:**
- 13 GitHub Actions workflows
- Unified Railway + Vercel deployment
- Deployment Harmony system with pre/post validation
- Health checks and uptime monitoring
- Accessibility scanning on every PR

**Requirements:**
1. **Pre-Deployment Validation Gates**:
   - Type consistency check (TypeScript strict mode)
   - Configuration validity verification
   - Database migration safety validation
   - Environment variable completeness check
   - Secret rotation status verification
   - Dependency vulnerability scanning
   - Performance regression detection
   - Accessibility compliance verification (Pa11y + axe-core)

2. **Coordinated Multi-Platform Deployment**:
   - Implement staged rollout: canary (5%) → partial (25%) → full (100%)
   - Blue-green deployment for zero-downtime updates
   - Synchronized Railway backend + Vercel frontend deployment
   - Rollback coordination across platforms
   - Health check validation post-deployment

3. **Post-Deployment Verification**:
   - Automated smoke test suite (API health, database connectivity)
   - E2E test execution against production environment
   - Performance metrics validation (response time, throughput)
   - Error rate monitoring (SLA enforcement)
   - Data integrity validation
   - SSL certificate verification
   - CDN cache invalidation

4. **Automatic Rollback & Recovery**:
   - Real-time monitoring with SLO alerts
   - Automatic rollback triggers:
     - Error rate > 5% for 5min
     - Response time p99 > 2s for 10min
     - Database connection failures
     - Health check failures > 3 consecutive
   - Coordinated rollback across Railway + Vercel
   - Incident notification system

5. **Deployment Analytics & Audit Trail**:
   - Complete deployment history with git diff
   - Performance baseline comparisons
   - Error rate comparisons (pre vs. post)
   - Deployment duration tracking
   - Rollback frequency analysis
   - Success rate metrics per release
   - Team member accountability tracking

6. **Advanced Safety Features**:
   - Database migration dry-run testing
   - Feature flag system for gradual rollout
   - Incident communication system
   - Deployment window enforcement
   - Concurrent deployment prevention

**Deliverables:**
- Pre-deployment validation framework (10+ gates)
- Staged rollout orchestration system
- Blue-green deployment implementation
- Post-deployment smoke test suite
- Automatic rollback detection and execution
- Deployment analytics dashboard
- Incident communication system

**Success Metrics:**
- Deployment success rate: 99.5%+
- Automated rollback response time: < 5 minutes
- Downtime per deployment: < 30 seconds
- Detection of issues: 100% (pre-deployment)
- Team confidence in deployments: 95%+ satisfaction

---

## Mega Prompt #4: System Performance Optimization & Scalability

**Objective:** Optimize backend performance to handle 10x traffic increase with sub-100ms API response times and reduce infrastructure costs by 35%.

**Current State:**
- Express.js API with 14 route modules
- PostgreSQL 15 with Prisma ORM
- Redis 7 for caching
- Bull 4.16.5 job queues
- Puppeteer 24.29.1 for DOM analysis
- 40+ API endpoints

**Requirements:**
1. **Database Query Optimization**:
   - Audit and optimize 40+ API endpoint queries
   - Implement query execution plans and explain analysis
   - Add strategic database indexing (missing index detection)
   - N+1 query elimination with batch loading
   - Connection pooling optimization (Prisma)
   - Read replica implementation for analytics queries
   - Materialized view creation for complex aggregations

2. **Caching Strategy Implementation**:
   - Multi-layer caching: memory → Redis → database
   - Cache invalidation strategy per entity type
   - Cache warming for frequently accessed data
   - Implement stale-while-revalidate pattern
   - ETags and conditional requests
   - Cache hit rate monitoring

3. **API Response Optimization**:
   - Response compression (Brotli/Gzip optimization)
   - Selective field returning (GraphQL-like filtering)
   - Pagination optimization (cursor-based vs. offset)
   - Lazy loading for nested resources
   - Response size reduction (target 50% smaller payloads)
   - Implement streaming for large responses

4. **Background Job Optimization**:
   - Job queue prioritization (critical → normal → background)
   - Parallel job processing with worker scaling
   - Dead letter queue optimization
   - Job retry strategy with exponential backoff
   - Job completion time tracking
   - Batch processing for similar jobs

5. **Frontend Performance**:
   - React component performance profiling
   - Lazy loading component implementation
   - Code splitting optimization
   - CSS-in-JS optimization (Tailwind purging)
   - Image optimization (WebP, lazy loading)
   - Build size analysis and reduction

6. **Infrastructure & DevOps**:
   - Railway auto-scaling configuration optimization
   - Database connection pooling tuning
   - Load testing and capacity planning
   - Memory profiling and leak detection
   - CPU optimization (algorithmic improvements)
   - Network optimization (CDN configuration)

**Deliverables:**
- Database query optimization report with metrics
- Multi-layer caching implementation
- API response compression and optimization
- Background job performance tuning
- Frontend bundle size reduction
- Load testing results and recommendations
- Performance monitoring dashboard

**Success Metrics:**
- API response time: p95 < 100ms
- Database query time: average < 50ms
- Cache hit rate: 70%+
- Infrastructure cost reduction: 35%
- Throughput capacity: 10x increase
- Frontend Lighthouse score: 90+

---

## Mega Prompt #5: WCAG Compliance Enhancement & Violation Detection Optimization

**Objective:** Increase WCAG violation detection accuracy to 95%+ and ensure generated sites meet AAA compliance standards with zero known violations.

**Current State:**
- axe-core accessibility scanning
- Pa11y integration for CI/CD
- Lighthouse accessibility audits
- Puppeteer DOM analysis
- 100+ WCAG success criteria support
- Confidence scoring system

**Requirements:**
1. **Comprehensive Violation Detection**:
   - Implement detection for all 78 WCAG 2.1 success criteria (AAA level)
   - Add temporal violation tracking (violations that appear intermittently)
   - Implement context-aware detection (specific to technology stack)
   - Create framework-specific detectors (React, Vue, Angular)
   - Add language-specific accessibility rules
   - Implement complex interaction testing (accordions, tabs, modals)

2. **Advanced Testing Coverage**:
   - Keyboard navigation testing (Tab, Enter, Escape, Arrow keys)
   - Screen reader compatibility testing (NVDA, JAWS, VoiceOver)
   - Focus management verification
   - ARIA implementation validation
   - Color contrast checking (WCAG 1.4.3 + enhanced)
   - Motion/animation sensitivity checks
   - Zoom level compatibility (200%+)

3. **Automated Remediation Verification**:
   - Post-fix re-scanning to verify compliance
   - Side-effect detection (fix doesn't break other functionality)
   - Regression testing against previously fixed violations
   - Browser compatibility verification (10+ browser matrix)
   - Device compatibility testing (mobile, tablet, desktop)
   - Assistive technology compatibility confirmation

4. **Fix Validation System**:
   - Implement automated fix validation rules per violation
   - Create test case generation for each fix
   - Implement visual regression testing
   - Add functionality regression testing
   - Create accessibility-specific assertions
   - Build fix health scoring system

5. **Compliance Reporting & Documentation**:
   - Generate VPAT 2.4A reports automatically
   - Create accessibility statement generation
   - Build statement of compliance per standard
   - Generate detailed remediation evidence
   - Create before/after accessibility reports
   - Implement compliance certification system

6. **Continuous Compliance Monitoring**:
   - Build post-deployment compliance monitoring
   - Implement regression detection (compliance degradation)
   - Create accessibility metrics dashboard
   - Track compliance trends over time
   - Alert on compliance violations
   - Generate monthly compliance reports

**Deliverables:**
- Comprehensive WCAG 2.1 AAA detector implementation
- Automated testing framework for 78 criteria
- Fix validation system with test generation
- VPAT and compliance report generators
- Post-fix verification system
- Continuous compliance monitoring dashboard
- Browser compatibility matrix testing

**Success Metrics:**
- Violation detection accuracy: 95%+
- Generated site compliance: 100% AAA
- False positive rate: < 2%
- Fix verification success: 98%+
- Time to compliance certification: 80% faster

---

## Mega Prompt #6: Multi-Tenant Architecture & Advanced Security Hardening

**Objective:** Implement enterprise-grade multi-tenancy with complete data isolation, RBAC, and advanced security features supporting 1000+ concurrent tenants.

**Current State:**
- Tenant isolation middleware
- Role-Based Access Control (admin, consultant, client, viewer)
- Clerk authentication
- JWT token-based API auth
- SSRF protection and URL validation
- Rate limiting: 100 req/15min
- Helmet.js security headers

**Requirements:**
1. **Complete Data Isolation**:
   - Implement row-level security (RLS) in PostgreSQL
   - Add tenant context validation on every query
   - Create tenant-aware database migrations
   - Implement data residency compliance
   - Add tenant-specific encryption keys
   - Verify no cross-tenant data leakage

2. **Advanced RBAC System**:
   - Implement attribute-based access control (ABAC)
   - Create custom permission system (50+ granular permissions)
   - Build organizational hierarchy support
   - Implement delegation workflows
   - Add permission audit trails
   - Create dynamic role assignment

3. **API Security Hardening**:
   - Implement OAuth 2.0 with PKCE flow
   - Add API key management system
   - Create rate limiting per tenant
   - Implement DDoS protection
   - Add request signing for critical operations
   - Implement request/response encryption
   - Add IP whitelist capability

4. **Data Protection**:
   - Implement field-level encryption for sensitive data
   - Add encryption-at-rest for S3 storage
   - Implement TLS 1.3 for all connections
   - Add secure session management
   - Implement secure cookie flags
   - Add CSRF token validation

5. **Audit & Compliance**:
   - Implement comprehensive audit logging (all operations)
   - Add data access logging
   - Create compliance reporting (SOC2, HIPAA, GDPR)
   - Implement data retention policies
   - Add deletion confirmation workflows
   - Create audit trail exports

6. **Incident Response & Monitoring**:
   - Implement intrusion detection system
   - Add anomaly detection alerts
   - Create incident response workflows
   - Implement security event logging
   - Add real-time security monitoring
   - Create security scorecard

**Deliverables:**
- Row-level security implementation in PostgreSQL
- Advanced RBAC system with ABAC support
- OAuth 2.0 + API key management
- Field-level encryption implementation
- Comprehensive audit logging system
- Compliance reporting framework
- Security monitoring and alerting system

**Success Metrics:**
- Data isolation: 100% verified
- Permission accuracy: 99.9%+
- Audit log completeness: 100%
- Security incident detection time: < 5 minutes
- Compliance readiness: 100% (SOC2, HIPAA, GDPR)
- Tenant security satisfaction: 98%+

---

## Mega Prompt #7: Observability, Monitoring & SLA Compliance System

**Objective:** Build comprehensive observability platform with distributed tracing, metrics, logs, and SLA enforcement achieving 99.95% uptime SLA.

**Current State:**
- Sentry for error tracking
- OpenTelemetry + Jaeger for distributed tracing
- Prometheus + Grafana for monitoring
- GitHub Actions health monitoring
- Health check endpoints
- Error tracking and reporting

**Requirements:**
1. **Distributed Tracing System**:
   - Implement end-to-end request tracing
   - Add service-to-service trace correlation
   - Create trace visualization dashboards
   - Implement trace sampling strategy (adaptive sampling)
   - Add custom span annotations per operation
   - Create latency SLO tracking per operation

2. **Metrics & Observability**:
   - Implement RED method (Request rate, Errors, Duration)
   - Add USE method (Utilization, Saturation, Errors)
   - Create service-specific metrics dashboards
   - Add business metrics (revenue, leads, conversions)
   - Implement percentile tracking (p50, p95, p99)
   - Create alerting thresholds per metric

3. **Log Aggregation & Analysis**:
   - Centralize logs from all services
   - Implement structured logging (JSON format)
   - Add correlation IDs across all logs
   - Create log filtering and search capabilities
   - Implement log retention policies
   - Add log-based alerting

4. **SLA & SLO Tracking**:
   - Define Service Level Objectives (SLOs):
     - API availability: 99.95%
     - Response time p95: < 100ms
     - Error rate: < 0.1%
   - Create SLO tracking dashboards
   - Implement SLA violation alerts
   - Add error budget tracking
   - Create compliance reporting

5. **Alerting & Incident Management**:
   - Create intelligent alerting (avoid false positives)
   - Implement alert routing (critical → on-call)
   - Add escalation procedures
   - Create incident declaration workflows
   - Implement notification channels (Slack, PagerDuty, email)
   - Add alert acknowledgment tracking

6. **Dashboard & Visualization**:
   - Create unified platform health dashboard
   - Build service-specific performance dashboards
   - Create team/project-specific views
   - Implement real-time alert dashboard
   - Add historical trend analysis
   - Create executive summary dashboards

**Deliverables:**
- End-to-end distributed tracing system
- Comprehensive metrics and RED/USE implementation
- Centralized log aggregation and analysis
- SLA/SLO tracking framework
- Intelligent alerting system
- Multi-level dashboards (operations, team, executive)
- Incident management integration

**Success Metrics:**
- Uptime SLA achievement: 99.95%+
- Mean time to detect (MTTD): < 5 minutes
- Mean time to resolution (MTTR): < 30 minutes
- Alert accuracy: 95%+ (meaningful alerts)
- Dashboard coverage: 100% of critical paths
- On-call satisfaction: 90%+

---

## Mega Prompt #8: Frontend Developer Experience & Component Architecture Modernization

**Objective:** Build modern component architecture with design system, developer tooling, and enhanced UX achieving 50% faster feature development.

**Current State:**
- React 18.2 with Vite 5.4.21
- Tailwind CSS styling
- Axios for API communication
- TypeScript for type safety
- Main components: ConsultantApprovalDashboard, ReviewDashboard, LeadDiscovery

**Requirements:**
1. **Design System & Component Library**:
   - Create reusable component library (50+ components)
   - Build Storybook documentation
   - Implement design tokens system
   - Create responsive grid system
   - Build typography system
   - Add color palette with accessibility validation
   - Create icon system

2. **State Management & Data Fetching**:
   - Evaluate and implement state management (Redux, Zustand, Jotai)
   - Create custom hooks library (useAPI, useForm, useModal, etc.)
   - Implement data caching strategy
   - Add optimistic updates
   - Create request deduplication
   - Implement error boundary system

3. **Developer Tooling & Workflows**:
   - Configure hot module replacement (HMR)
   - Create development environment setup guide
   - Implement debug logging system
   - Build mock server for API development
   - Create code generation tools (scaffolding)
   - Add linting and formatting (ESLint, Prettier)

4. **Performance Optimization**:
   - Implement React concurrent rendering
   - Add component lazy loading
   - Create code splitting strategy
   - Implement virtualization for long lists
   - Add memoization where appropriate
   - Create bundle analysis tooling

5. **Testing Infrastructure**:
   - Configure Jest for unit testing
   - Add React Testing Library for component testing
   - Create E2E test framework (Playwright/Cypress)
   - Build accessibility testing into tests
   - Create visual regression testing
   - Implement test coverage reporting

6. **Documentation & Developer Experience**:
   - Create living component documentation
   - Build design system documentation site
   - Create development best practices guide
   - Build onboarding guide for new developers
   - Create troubleshooting documentation
   - Add video tutorials

**Deliverables:**
- Component library with 50+ components
- Design tokens system
- Storybook documentation
- Custom hooks library
- State management implementation
- Development environment setup guide
- Testing framework setup
- Performance optimization improvements
- Developer documentation site

**Success Metrics:**
- Feature development speed: 50% faster
- Component reusability rate: 80%+
- Test coverage: 80%+
- Build time: 50% reduction
- Developer satisfaction: 9/10
- Onboarding time for new developers: 50% faster

---

## Mega Prompt #9: Resilience, Error Handling & Graceful Degradation System

**Objective:** Build enterprise-grade resilience patterns with circuit breakers, graceful degradation, and comprehensive error recovery achieving 99.99% request success rate.

**Current State:**
- Global error handler with RFC 7807 format
- Circuit breaker pattern mentions
- Dead letter queue for failed jobs
- External API client with resilience
- Retry logic with exponential backoff
- 13 GitHub Actions for CI/CD

**Requirements:**
1. **Circuit Breaker Pattern Implementation**:
   - Implement circuit breaker for external API calls
   - Create per-endpoint circuit breaker configuration
   - Add half-open state with probing
   - Implement fallback mechanisms
   - Add circuit breaker state monitoring
   - Create circuit breaker testing framework

2. **Comprehensive Error Handling**:
   - Classify errors (retryable vs. non-retryable)
   - Implement error recovery strategies per error type
   - Add user-friendly error messages
   - Create error context logging
   - Implement error grouping and trending
   - Add error severity classification

3. **Graceful Degradation Strategies**:
   - Implement feature flag system
   - Add fallback data sources
   - Create cache-based degradation
   - Implement read-only mode on critical failures
   - Add partial response capability
   - Create service dependency mapping

4. **Retry Strategy & Backoff**:
   - Implement exponential backoff with jitter
   - Add max retry limits per operation
   - Create retry policy per API/service
   - Implement deadline-aware retries
   - Add retry budget management
   - Create retry metric tracking

5. **Bulk Head & Isolation**:
   - Implement thread pool isolation per service
   - Add request queue management
   - Create resource limit enforcement
   - Implement timeout management
   - Add concurrency control
   - Create isolation testing

6. **Recovery & Healing**:
   - Implement self-healing mechanisms
   - Add automatic service health recovery
   - Create cache invalidation on failures
   - Implement connection pool recovery
   - Add state reconciliation
   - Create recovery metric tracking

**Deliverables:**
- Circuit breaker implementation framework
- Comprehensive error classification and handling
- Graceful degradation system
- Intelligent retry strategy
- Bulk head and isolation implementation
- Self-healing recovery system
- Error and recovery monitoring dashboards
- Resilience testing framework

**Success Metrics:**
- Request success rate: 99.99%+
- Error recovery time: < 5 seconds
- Circuit breaker effectiveness: 98%+ accuracy
- Graceful degradation activation: < 100ms
- User-visible error rate: < 0.01%
- Incident recovery time: < 2 minutes

---

## Mega Prompt #10: Cost Optimization & Infrastructure Efficiency Engineering

**Objective:** Reduce infrastructure and AI API costs by 45% while improving performance through intelligent optimization and resource management.

**Current State:**
- Railway backend deployment with auto-scaling
- Vercel frontend hosting
- AWS S3 for storage
- OpenAI + Anthropic API usage
- PostgreSQL + Redis infrastructure
- Docker containerization
- 13 GitHub Actions workflows

**Requirements:**
1. **AI API Cost Optimization**:
   - Implement token usage tracking per request
   - Create prompt caching strategy (Claude prompt caching)
   - Add model selection optimization (cheaper models for simple tasks)
   - Implement request batching for efficiency
   - Create API usage budgets and alerts
   - Add cost-per-fix tracking

2. **Infrastructure Cost Reduction**:
   - Optimize Railway auto-scaling configuration
   - Right-size database instance (analyze actual usage)
   - Implement connection pooling optimization
   - Reduce storage costs (S3 tiering strategy)
   - Optimize CDN usage (Vercel)
   - Implement resource cleanup automation

3. **Database Optimization**:
   - Identify and remove unused indexes
   - Optimize table structures and data types
   - Implement data archiving strategy
   - Add automated maintenance tasks
   - Optimize backup strategy (frequency, retention)
   - Implement query caching

4. **Cache Strategy Optimization**:
   - Implement Redis cost optimization
   - Optimize cache expiration policies
   - Reduce cache memory footprint
   - Implement cache compression
   - Add cache hit rate optimization
   - Create cache efficiency metrics

5. **API & Network Optimization**:
   - Minimize API calls through batching
   - Implement request deduplication
   - Add CDN cache headers optimization
   - Optimize payload sizes (50% target reduction)
   - Implement compression strategies
   - Add network protocol optimization

6. **Monitoring & Optimization Automation**:
   - Create cost tracking dashboard
   - Implement cost anomaly detection
   - Add optimization recommendations engine
   - Create automated cost reduction triggers
   - Build cost allocation per tenant/project
   - Implement FinOps practices

7. **Energy & Environmental Efficiency**:
   - Calculate carbon footprint per request
   - Implement green computing practices
   - Optimize energy-efficient algorithms
   - Track PUE (Power Usage Effectiveness)
   - Create environmental impact reporting

**Deliverables:**
- AI API cost optimization framework
- Infrastructure cost analysis and recommendations
- Database optimization implementation
- Cache efficiency optimization
- Network payload optimization
- Cost tracking and monitoring dashboard
- Automated cost reduction system
- Carbon footprint tracking

**Success Metrics:**
- Cost reduction: 45% overall
- AI API cost reduction: 40%
- Infrastructure cost reduction: 35%
- Token usage per fix: 30% reduction
- Cost per $1 revenue: 50% reduction
- Carbon footprint per transaction: 40% reduction

---

## Implementation Priorities & Dependencies

**Phase 1 (Weeks 1-3):** Foundation & Stability
- Mega Prompt #3: Deployment Safety (improves reliability)
- Mega Prompt #7: Observability (enables everything else)
- Mega Prompt #9: Error Handling (foundational)

**Phase 2 (Weeks 4-6):** Core Optimization
- Mega Prompt #1: AI Remediation (core business value)
- Mega Prompt #5: WCAG Compliance (quality)
- Mega Prompt #4: Performance (supports growth)

**Phase 3 (Weeks 7-9):** Enterprise Scaling
- Mega Prompt #6: Multi-Tenant Security (enterprise needs)
- Mega Prompt #2: Lead Discovery (revenue growth)
- Mega Prompt #10: Cost Optimization (profitability)

**Phase 4 (Weeks 10+):** Developer & User Experience
- Mega Prompt #8: Frontend Developer Experience
- Continuous refinement based on learnings

---

## Cross-Cutting Concerns

**All mega prompts should address:**
- Security & data privacy
- Performance implications
- Cost considerations
- Monitoring & observability
- Testing & validation
- Documentation requirements
- Backward compatibility
- User/developer experience

---

**Document Version:** 1.0
**Last Updated:** 2025-11-18
**Next Review:** Post-Phase 1 completion
